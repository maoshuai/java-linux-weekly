---
title: 第4期：创建class的正确姿势——从嵌套类到lambda（上）
---

# 定义class的姿势
我们几乎每天都在创建class，除了熟练的新建一个`.java`文件，写上`public class MyClass{}`之外，你还见过哪些奇葩的类定义？不错，你可能听说过：嵌套类、内部类、匿名类、lambda，以及在同一个java文件定义多个类，它们乍一看很别扭，总是让你糊里糊涂的，但实际上它们很简单，下面我们就各个击破吧！


# 什么是嵌套类
Java Tutorial里给出的定义是：
> The Java programming language allows you to define a class **within another class.** Such a class is called a nested class.

即如果一个类**定义在了另外一个类内部**，则称为嵌套类（Netsted Class），比如像这样，`NestedClass`就是一个嵌套类。

```Java
class OuterClass {
    ...
    class NestedClass {
        ...
    }
}
```

一句within another class，说来轻松，但问题来了：

1. 所谓**定义在内部**有哪些形式的“内部”？
2. 每种形式的嵌套类与外部有什么关系呢？

这些是我们研究嵌套类时需要考虑的。下面逐一展开。

# 嵌套类的分类
根据 Java Tutorial 里的介绍，嵌套类，首先根据是否用static修饰，分为两大类：**静态嵌套类（static nested classes）**和**内部类（inner class）**。

>  **Terminology:**Nested classes are divided into two categories: static and non-static. Nested classes that are declared`static`are called*static nested classes*. Non-static nested classes are called*inner classes*.

```Java
class OuterClass {
    ...
    static class StaticNestedClass {
        ...
    }
    class InnerClass {
        ...
    }
}
```

进一步，内部类又可以分为：局部类、匿名类、lambda表达式。

我们首先从“静态嵌套类”开始。

# 静态嵌套类

相比内部类，静态嵌套类的使用和变化更为简单，静态嵌套类只能定义为**外部类的static成员**。相比之下，内部类可以还可以定义在方法内部。静态嵌套类的基本形式是：

```Java
class OuterClass {
    static class StaticNestedClass {
    }
}
```

## 无法直接访问外部类实例成员
和静态方法或静态变量一样，静态嵌套类是**类成员**，因此静态外部类不能**直接**访问外部类的实例方法或变量。比如：

```Java
package com.imshuai.javalinux.w4.staticnested;
public class OuterClass {	public String outerName = "outerName";	public static class StaticNetstedClass{		public void print() {			/*			 *  编译错误: Cannot make a static reference			 *  to the non-static field outerName			 */			System.out.println(outerName);		}	}}
```

但静态嵌套类可以像其他普通类一样，通过**创建外部类的实例**访问外部类的实例变量：

```Java
package com.imshuai.javalinux.w4.staticnested;
public class OuterClass {	public String outerName = "outerName";	public static class StaticNetstedClass{		public void print() {			// 通过实例访问，与普通类无异			System.out.println(new OuterClass().outerName);		}	}}
```

但是，静态嵌套类还是有**嵌套类的优待**的：**可以访问外部类实例的private成员**，比如上面的`outerName`修改为`private`，`StaticNetstedClass.print()`一样可以访问：

```Java
package com.imshuai.javalinux.w4.staticnested;
public class OuterClass {
	private String outerName = "outerName";	public static class StaticNetstedClass{		public void print() {			// 通过实例访问，可以访问private变量			System.out.println(new OuterClass().outerName);		}	}}
```

## 静态嵌套类的引用方式

下面是在外部引用和实例化静态类的例子：

```Java
// 无法直接判断OuterClass是报名还是外部类import com.imshuai.javalinux.w4.staticnested.OuterClass.StaticNetstedClass;public class Main {	public static void main(String[] args) {		StaticNetstedClass snc = new StaticNetstedClass();		snc.print();	}}
```

从上面的用法看，静态嵌套类其实与普通的类并无太大区别，甚至看起来，包裹它的外部类就像它的包名而已。`StaticNetstedClass`看起来好像包名就是：`com.imshuai.javalinux.w4.staticnested.OuterClass`

不过，更清晰的表示是带上`OuterClass.`作为自己的前缀，就像这样：

```Java
package com.imshuai.javalinux.w4;
import com.imshuai.javalinux.w4.staticnested.OuterClass;public class Main {	public static void main(String[] args) {		// 带上OuterClass，表明是自己是嵌套类		OuterClass.StaticNetstedClass snc = new OuterClass.StaticNetstedClass();		snc.print();	}}
```

## 静态嵌套类的访问权限

我们知道一个普通类一般只能被声明为`public`或`package`访问权限。而在外部类的管理下，静态嵌套类的访问权限，完全由外部类说的算。这就带来了一个有意思的结果：静态嵌套类可以是private、protected、public或package的。比如下面，`StaticNetstedClass`只能由`OuterClass`自己或其子类声明和使用：

```Java
public class OuterClass {	private String outerName = "outerName";	// 只有OuterClass的子类可以声明和使用	protected static class StaticNetstedClass{		public void print() {			System.out.println(new OuterClass().outerName);		}	}}
```

## 关于接口
由于接口**本质上是静态的**，所以如果在一个类内部定义接口，虽然没有使用static，依然是static的，可以当做静态嵌套类，而不是内部类。

**静态嵌套类小结：**
1. 和静态方法类似，静态嵌套类不能**直接访问**外部类的实例变量或方法，但可以直接访问外部类的static变量或方法。
2. 静态嵌套类具有所有嵌套类的优待：可以**访问外部类的private成员**。
3. 对于静态嵌套类，外部类就像是充当一个**特殊的“包名”**，将静态嵌套类**封印**在自己的内部，灵活的对外提供private、protected、public以及package访问控制。

# 内部类

相比静态嵌套类，内部类（或者说非静态嵌套类）更复杂，变化也更多。内部类根据其scope可以分为：

1. 一般内部类（声明为外部类的实例成员）
2. 局部类（声明为方法的局部成员）
3. 匿名类（没有名字，用完即焚）
4. lambda表达式（Java 8提供的匿名类）

下面逐一介绍。

## 内部类的实例化

我们先研究一般内部类，即被定义为外部类非static成员的内部类。其基本形式是：

```Java
public class OuterClass {	public class InnerClass{	}}
```

由于内部类总是与一个实例关联，因此**内部类无法单独实例化**。在外部类之外，需先实例化一个外部类，然后通过外部类的实例才能实例化内部类，这样**保证了内部类实例总是绑定了外部类实例**。下面举例说明。

我先定义过一个简单的外部类和内部类：

```Java
package com.imshuai.javalinux.w4.inner;
public class OuterClass {	public class InnerClass{	}}
```

下面是实例化的步骤：

```Java 
package com.imshuai.javalinux.w4;import com.imshuai.javalinux.w4.inner.OuterClass;public class Main {	public static void main(String[] args) {		OuterClass outerObject = new OuterClass();		OuterClass.InnerClass innerObject = outerObject.new InnerClass();	}}
```

最后一句，`outerObject.new InnerClass()`，**关键字`new`带一个前缀**，用来说明绑定的外部实例。

如果硬改成像嵌套静态类那样直接实例化，编译会有如下报错：

```Java
/* 编译报错:
- No enclosing instance of type OuterClass is accessible. 
Must qualify the allocation with an enclosing instance of type
OuterClass (e.g. x.new A() where x is an instance of OuterClass).
*/
OuterClass.InnerClass innerObject = new OuterClass.InnerClass();
```

## 内部类的static限制

内部类不能定义和声明static成员。Java Tutorial给出的原因是内部类总是和一个实例关联，所以不能定义static：
>  because an inner class is associated with an instance, it cannot define any static members itself.

为什么这样，其实Oracle的Java Tutorial并没有说清楚。不过我觉得这可能只是人为限制，因为我们可以让内部类通过继承一个含有是static成员或方法的父类突破这一限制（如下例），既然可以通过继承调用静态方法，为什么不能直接包含静态方法呢？下

```Java
package com.imshuai.javalinux.w4.inner;class StaticParent{	public static void print() {		System.out.println("Static parent");	}}class Outer {	class Inner extends StaticParent{	}}public class InnerClassStatic{	public static void main(String[] args) {		Outer.Inner.print();	}}
```

## 内部类可访问外部类的实例变量或方法

和实例变量或实例方法一样，内部类与外部类的实例相关联，并且可以**直接访问外部类的实例变量或实例方法**。

```Java
package com.imshuai.javalinux.w4.inner;public class OuterClass {	private String name = "Jack";	public class InnerClass{		public void printName() {			System.out.println(name);		}		public void setName(String newName) {			name = newName;		}	}}
```

## 变量定义覆盖

内部类如果定义了和外部类一样的变量名，则在内部类中也会出现类似的覆盖现象（shadowing），如果需要访问外部类的变量，则需要通过外部类的类名进行区分，比如下面的例子：

```Java
package com.imshuai.javalinux.w4.inner;public class ShadowTest {	public int x = 0;    class FirstLevel {        public int x = 1;        void methodInFirstLevel(int x) {            System.out.println("x = " + x);            System.out.println("this.x = " + this.x);            System.out.println("ShadowTest.this.x = " + ShadowTest.this.x);        }    }    public static void main(String... args) {        ShadowTest st = new ShadowTest();        ShadowTest.FirstLevel fl = st.new FirstLevel();        fl.methodInFirstLevel(23);    }}
```

方法参数、内部类以及外部类都有相同变量名`x`。此时直接写`x`代表最近的定义，即方法参数；`this`指代内部类；而外部类的`x`，需要增加类名`ShadowTest`再加上`this`。

所以，类名+this+变量名的形式才是实例成员的完全体，即便没有冲突你可以这样写，就是太啰罢了：
```Java
public class ThisTest {		private String name;	public void print() {		System.out.println(ThisTest.this.name);	}}
```

# 内部类之局部类

除了上面将内部类定义在class内，还可以**定义在代码段里（比如方法体内），称作局部类（Local Class）**。下面代码中`PhoneNumber`就是一个局部类的例子，它定义在了`validatePhoneNumber`的方法体内：

```Java
package com.imshuai.javalinux.w4.lcoal;public class LocalClassExample {	private static String regularExpression = "[^0-9]";	public static void validatePhoneNumber(String phoneNumber1, String phoneNumber2) {		final int numberLength = 10;		// 局部类，包含业务逻辑		class PhoneNumber{			String formattedPhoneNumber = null;			public PhoneNumber(String phoneNumber) {				String currentNumber = phoneNumber.replaceAll(regularExpression, "");				if(currentNumber.length() == numberLength) {					formattedPhoneNumber = currentNumber;				}else {					formattedPhoneNumber = "INVALID";				}			}			public String getNumber() {				return formattedPhoneNumber;			}		}				// 实例化局部类		PhoneNumber myNumber1 = new PhoneNumber(phoneNumber1);		PhoneNumber myNumber2 = new PhoneNumber(phoneNumber2);				System.out.println("First number is " + myNumber1.getNumber());		System.out.println("Second number is " + myNumber2.getNumber());	}		public static void main(String[] args) {		validatePhoneNumber("123-456-7890", "456-7890");	}}
```

上面的代码，局部类`PhoneNumber`，封装了对电话号码的格式验证的逻辑。那为什么使用局部类呢？想象一下，如果验证电话号码的逻辑不用局部类，可以怎么实现？最常规的办法就是将逻辑抽象成一个private方法供`validatePhoneNumber`调用，比如这样：

```Java
package com.imshuai.javalinux.w4.lcoal;public class LocalClassExampleOtherwise {	private static String regularExpression = "[^0-9]";	public static void validatePhoneNumber(String phoneNumber1, String phoneNumber2) {		// 实例化局部类		String myNumber1 = getFormatedNumber(phoneNumber1);		String myNumber2 = getFormatedNumber(phoneNumber2);		System.out.println("First number is " + myNumber1);		System.out.println("Second number is " + myNumber2);	}	private static String getFormatedNumber(String phoneNumber) {		final int numberLength = 10;		String formattedPhoneNumber = null;		String currentNumber = phoneNumber.replaceAll(regularExpression, "");		if(currentNumber.length() == numberLength) {			formattedPhoneNumber = currentNumber;		}else {			formattedPhoneNumber = "INVALID";		}		return formattedPhoneNumber;	}		public static void main(String[] args) {		validatePhoneNumber("123-456-7890", "456-7890");	}}
```

相比而言：
1. private方法扩大了代码的scope，本来只是`validatePhoneNumber`内部的逻辑，现在变成了整个class的逻辑。
2. 如果对电话号码增加更多的逻辑，可能会产生**更多的private方法**，而这一切都却可以在local class里轻易扩展的。
3. 局部类天然的可以访问方法的局部变量，如果抽象成private方法，需要传递参数。

因此，局部类，相当于封装了一段需**要在方法内复用**的代码，这段代码只在当前方法可以使用，是一种比private方法更严格的做法。

但我觉得，如果**外部类逻辑本身比较纯粹和简单**，使用局部类意义并不大。因为这个外部类的存在本身就是为了封装这段逻辑，何必再搞一层？而且class内部的private方法是完全在掌控之内的。

## 局部类访问局部变量

局部类相比一般内部类的一个优势是，可以直接访问局部变量，包括方法的参数、方法体内定义的局部变量。比如上面的例子，局部类`PhoneNumber`访问了局部变量`numberLength`。

上例中，`numberLength`被声明为`final`，否则可能无法编译通过，**这是局部类访问局部变量的final限制**。但从JDK 8开始，局部变量也可以不是final的，但仍然要像final一样对待，即不能修改局部变量（包括外部方法本身），称作为**等效final**（effectively final.）。

Java为什么要这样限制局部类呢？这是因为**局部类的生命周期可能在外部方法之外**。比如下面的例子：

我们先定义一个接口：
```Java
public interface TestInterface{	public void internalTestFunction();}
```

然后在一个方法内定义局部类，并在main函数访问：

```Java
public class VariableCapture {	public static TestInterface testFunction () {		int value = 3;		class LocalClsss implements TestInterface{			@Override			public void internalTestFunction() {				System.out.println(value);			}		}		return new LocalClsss();	}	
	public static void main(String []args) {        TestInterface testObject = testFunction();          testObject.internalTestFunction();     }}
```

方法`testFunction`的局部变量`value`在`testFunction`执行完毕后，就应该销毁了。但后续的`internalTestFunction`方法是局部类的方法，还会继续执行。为了保证局部类对`value`的正常访问，局部类**实际上是复制了一份局部变量**，因此这种被局部类反问的变量，在Java里称作**俘获变量（captured variable）**。Java为了保证两份拷贝的一致性，所以需要保证俘获变量是final或等效final的。

## 局部类访问类成员

局部类和内部类一样，可以访问所在外部类的成员。但要注意的是，**局部类如果在static方法内定义，则不能访问外部类的实例成员**。这一点也很容用理解，因为static方法并不依赖于实例话，所以局部类并没有对应的实例可绑定。


**局部类小结：**
1. 局部类也是一中内部类，只不过“更内部”，从class成员，变成了方法的内部。
2. 局部类除了可以访问外部类的实例变量和方法外，还可以访问方法的局部变量，但访问的局部变量必须是final或等效final的。
3. 局部类访问外部类的变量，受包含包含方法的影响。如果包含方法是static的，则局部类只能访问外部类的static成员；如果包含方法是非static的，则不受此限制。
4. 局部类的scope仅存在代码段的局部，外部无法使用。
5. 和内部类一样，局部类不能定义或声明static成员。

# 内部类之匿名类

匿名类，更进一步，将其scope限制到**用后即焚烧**。

# 为什么使用嵌套类

1. 如果A类只对被B类一个类使用，把A直接嵌入B
2. 增加了封装性。内部类可以访问包含类的private方法。如果不使用内部类，则包含类的private就必须声明为非private，但降低了封装性。
3. 可读性和可维护性。逻辑上更近。

# JDK中嵌套类的使用举例

# 嵌套类的修饰符

# 嵌套类的要点
嵌套类的形式
每种形式和外部类的关系

# 总结
做个图表对比
做个脑图，表示各种类的区别和关系。放在第一章

# 名词
caputure varaible
enclosing class
称为外部类或包含类。

# 杂项
看起来像函数
类似javascript中的this绑定问题
两个实例的class是否是同一个class对象？
内部类最好只服务外部类，比如作为一个helper
还有一种定义在同一个类文件的类
各种类的定义基本形式
一个java文件里不一定有同名的class定义。
private的隐含意思就是class的内部。因此对一个class的访问权限，不存在private之说。

package比subclass更亲近

使用types指代class或interface
types refers to classes, interfaces, enumerations, and annotation types.

# 编译出来的形式
不同类型的class，编译出来的class文件有什么区别？

# 参考
* [Nested Classes (The Java™ Tutorials > Learning the Java Language  > Classes and Objects)](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html)
* [Variable Capture in Java](http://www.devcodenote.com/2015/04/variable-capture-in-java.html)
* [java - Why can't we have static method in a (non-static) inner class - Stack Overflow](https://stackoverflow.com/questions/975134/why-cant-we-have-static-method-in-a-non-static-inner-class)